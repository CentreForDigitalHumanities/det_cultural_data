{
  "hash": "1d814b6dfd9d3297cfb158a75b88ed59",
  "result": {
    "markdown": "---\ntitle: \"Introduction to Python\"\nexecute:   \n  enabled: true\n  error: true\n  freeze: auto\n---\n\nIn this session, we will introduce you to Jupyter Notebooks and guide you through some of the essential programming concepts that form the foundation of working with data. Whether you are completely new to programming or looking to strengthen your understanding, this chapter is designed to help you build confidence as you take your first steps into coding.\n\nThis session is very python-specific, but (as you will find out in few lines) Jupyter Notebook is compatible with many programming languages and the programming concepts introduced here are fundamentals of every programming language. \n\nA Jupyter Notebook is an interactive environment where you can write and execute code in small, manageable pieces, known as cells. This allows you to see the results of your code immediately, making it an excellent tool for learning, experimenting, and exploring data. It combines text, code, and the results of that code all in one place, making it a popular choice for data scientists, researchers, and educators.\n\nIn this session, we will be using Python, a programming language known for its simplicity and readability, which makes it ideal for beginners. We will cover core programming concepts, such as variables, functions, and loops, and you will learn how to apply these concepts to perform basic data exploration tasks.a\n\n# Getting familiar with Jupyter Notebook {.unnumbered}\n\nJupyter Notebook is an open-source web application that allows you to create and share documents containing live code, equations, visualizations, and narrative text. It supports various programming languages, including Python, R, Julia, and more. However, it is most commonly used with Python.\n\nJupyter Notebook provides an interactive computing environment where you can write and execute code in a series of cells. Each cell can contain code, markdown text, equations, or visualizations. You can run individual cells or the entire notebook to see the output of the code and the results of any computations.\n\nThe name \"Jupyter\" is a combination of three programming languages: Julia, Python, and R, which were the first three languages supported by the Jupyter project. It was originally developed as part of the IPython project (hence the name \"Jupyter\"), but has since evolved into a language-agnostic tool that supports multiple programming languages.\n\nIn the context of Python, Jupyter Notebook is a popular tool for data analysis, scientific computing, machine learning, education, and research. It allows users to write, test, and document Python code in an interactive and visually appealing manner, making it a valuable tool for both beginners and experienced programmers alike.\n\n# Jupyter Notebook cells {.unnumbered}\n\nJupyter notebook cells can be either code, markdown, or raw. For the simple purpose of programming and writing text, ignore the raw option. You can easily shift between code and markdown selecting the cell, pressing Esc, and then M for markdown or Y for code.\n\nMarkdown is a language for formatting text, it allows you to quickly and easily create formatted documents using simple and intuitive syntax. This current cell and any other cell displaying text in this notebook, is written in markdown. You can learn the basics of markdown syntax in few minutes reading [here](https://www.markdownguide.org/) or simply looking at the content of the text cells in this notebook and see what happens when you select them and run them.\n\nYou can tell if your cell selected cell is a code cell because you will see square brackets on its left ([ ]:).\n\nIf you want to delete a cell, use Esc + DD (press Esc and then d twice)\n\n**WARNING**: If your code cell has *empty* squred brackets, it means it has not been run YET. \n\n# Main programming concepts {.unnumbered}\n\nThere are some programming concepts that are common to all programming languages and can be found in any program: \n\n- variables and data types;\n- sequences of objects;\n- functions;\n- loops;\n- conditional statements;\n- packages (also called libraries or modules)\n\n## Variables and data types {.unnumbered}\n\nIn programming a variable is a container for a value. This value can either be a number, a string (a word), or any other type of programming object (we will talk about other possible objects later). Let's initialise (define for the first time) some variables:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nname = 'Stefano'\nfavourite_planet = 'Saturn'\nbirth_day = 6\n```\n:::\n\n\nIn the previous cell we stored the word *Stefano* into the variable ```name```, the word *Saturn* into the variable ```favourite_planet```, and the value 6 into the variable ```birth_day```. From now on, every time we need to use one of these values in our programming, we just need to digit its corresponding variable name.\n\nIn Jupyter notebooks, if you want to check the value contained in a variable (so its content), you can simply run a cell with the variable name inside:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nname\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n'Stefano'\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nbirth_day\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n6\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nname\nbirth_day\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n6\n```\n:::\n:::\n\n\nAs you can notice, when you write different variable names in the same cell, only the last one will be printed on the screen.\n\n## Sequences of objects {.unnumbered}\n\nWe can store single numbers and words inside a variable, but how about we want to store a *sequence* of values or words, or a mix of the two, into a variable? Of course we can, we just need to use a python object called **list**:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nnames = ['Stefano','Pippo','Alfio','Tano']\nages = [20,34,94,'unknown']\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nnames[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n'Stefano'\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nages[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n'unknown'\n```\n:::\n:::\n\n\nIn Python lists are defined listing our sequence of values separated by coma inside square brackets (variable_name = [... , ... , ...]). Values stored in a list can be accessed using **indexing**. In python you count items starting from 0, so that the first item in a list has index 0. This means that for accessing the first item in the list ```names``` we will digit ```name[0]```, and to access the last item in the list ```ages``` we will digit ```ages[3]``` \n\nYou can create lists of *any* object, even lists of lists:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ninfo = [names,ages]\ninfo[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n['Stefano', 'Pippo', 'Alfio', 'Tano']\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ninfo[0][0]\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n'Stefano'\n```\n:::\n:::\n\n\nIf we want to change a particular value in a list, we first need to access it and then we need to use the operator = to specify the new list value. For example, if we want to change 'Stefano' into 'Steve', we would do:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ninfo[0][0] = 'Steve'\ninfo[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n['Steve', 'Pippo', 'Alfio', 'Tano']\n```\n:::\n:::\n\n\n## Data types: Dictionaries {.unnumbered}\n\nIn python there are several ways you can store information. We just talked about lists, simple ordered sequences of objects. Another kind of data structure is called **dictionary**. In general a dictionary is a reference or resource that provides information, definitions, or explanations of words, terms, concepts, or objects. A dictionary is usually organised by alphabetically ordered words and by explanations associated to each word. In python a dictionary follows exactly the same organization principle: keyword and value.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ninfo_dict = {'name':'Stefano','favourite_number':6}\n```\n:::\n\n\nTo define a dictionary we use curled brackets ({}) instead of squared brackets. Inside the curled brackets we need to specify couples of key/values separated by comas. To each key we can associate a different python object. Keys need to be unique, while values can by any Python object.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ninfo_dict = {'names':names}\n```\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ninfo_dict['names']\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n['Steve', 'Pippo', 'Alfio', 'Tano']\n```\n:::\n:::\n\n\nTo access the values contained inside a dictionary you cannot use numerical indices, as you would do for lists. Instead, you must use the name of the key related to the value. In the previous case the object names (a Python list) is associated with the key 'names'. So, in order to access it, we need to digit ```info_dict['names']```.\n\nIn a similar way, if you want to change the value related to a key, or create a new key/value couple, you first need to access that value and then to use the '=' sign to assign a new value\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ninfo_dict['names'] = ['Steve','Josef','Alfonse','Gerrit']\ninfo_dict['names']\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n['Steve', 'Josef', 'Alfonse', 'Gerrit']\n```\n:::\n:::\n\n\n## Functions {.unnumbered}\n\nA function is a python object that performs a single action given some parameters. In python, function names are usually verbs. If variable can be thought as subjects and objects in a sentence, functions are the verbs. Python has already some default functions, functions that are ready to use. [Here](https://docs.python.org/3/library/functions.html) you can find the build-in Python functions.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nresult = print(name)\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStefano\n```\n:::\n:::\n\n\nThe way a function works is common to all programming languages: you give to the function one or more parameters, the function performs an action, and it returns a result. This happens so fast that, as a matter of fact, you can already think at a function and its parameters as its result. \nIn the previous cell the function ```print()``` got as an input parameter the variable name and it printed its value on the screen. \n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nnumbers = [1,2,3,4,5,6,7,8,9,10]\nresult = sum(numbers)\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n55\n```\n:::\n:::\n\n\nIn the previous cell, we defined a list of values (the first 10 integers), then we used the function sum to (guess what??) sum all the numbers in the list, and we stored the result into the variable ```result```. We finally printed the result using the function ```print()```.\n\nBecause we know that variable values are printed automatically in Jupyter notebook cells when they contain the variable name, we could write directly:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nsum(numbers)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n55\n```\n:::\n:::\n\n\nIndeed ```sum(numbers)``` represents an operation that returns the value 55 and can be considered equivalent to the value 55 itself, so that when we write it in a cell, we obtain the result printed on the screen.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nlen(numbers)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n10\n```\n:::\n:::\n\n\nThe function ```len()``` is one of the most used function on objects containing many items. Indeed it tell us how many items are contained in that object (i.e. the length of that object). The function ```type()``` returns the type of a variable:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ntype(numbers)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\nlist\n```\n:::\n:::\n\n\nHow many functions are there? thousands, probably millions. Some of them have very intuitive names (like ```print()``` and ```sum()```), some others have more complicated names. However, every function that can be used in Python comes with its own documentation, explaining which parameters it accepts, which additional options you can specify, and which kind of result you get back when applying it. To find about a function just google \"<function_name> Python documentation\" or ask ChatGPT about that.\n\n## Methods {.unnumbered}\n\nMethods are functions that are object-specific. What does it mean? There are certain operations that can be perfomed only on a certain type of object. For example, if we consider a function that transforms lower characters into capital letters, it would not make much sense to apply this function to a number.\n\nAll objects in python can have their own specific functions and these object-specific functions are called **methods**. To use a method on an object, you need to apply the syntax ```<object_name>.method()```. Do you see the difference compared to a general function syntax? In a general function we have ```function(par1,par2,...)```, while in a method we already know that the function, in this case method, will be applied to its object. Therefore, inside the parenthesis we only have additional parameters.\n\nLike functions, methods can accept all kind of parameters, but, of course, their main parameter is the object itself. Let's see some example:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nname = 'Stefano Rapisarda Arthurus Micaelus'\nnumbers = [1,2,3,4,5]\n```\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nname.split()\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n['Stefano', 'Rapisarda', 'Arthurus', 'Micaelus']\n```\n:::\n:::\n\n\nWe initialised two variables: a string made of several words and a list of numbers. The split() method (a string-specific function) divides the string into a list of strings according to a separator. If you dont' specify any separator (like in our case), white spaces will be considered as separators. Let's see another example:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nnumbers.pop(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n3\n```\n:::\n:::\n\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nnumbers\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n[1, 2, 4, 5]\n```\n:::\n:::\n\n\nWe initialised two variables: a string made of several words and a list of numbers. The ```split()``` method (a string-specific function) divides the string into a list of strings according to a separator. If you dont' specify any separator (like in our case), white spaces will be considered as separators. The variable ```numbers``` is already a list and using the method ```pop(x)``` we can remove the item occupying the 3rd position (index 2). The method affects the list and returns the just removed value. \n\nHow can we found about methods if there are so many? Usually a google search can point you at the method or function you need. In general you can always consult python documentation. You will find about string a list methods [here](https://docs.python.org/3/library/stdtypes.html#string-methods) and [here](https://docs.python.org/3/tutorial/datastructures.html), respectively.\n\n## Loops {.unnumbered}\n\nOne of the potential of using machines is making them repeating the same operation hundreds, millions, or billions of times.\n\nLet's say I have a list of names and I want to print them on the screen one by one:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nnames = ['James','Martin','Sandra','Paul','Chani']\nprint(names[0])\nprint(names[1])\nprint(names[2])\nprint(names[3])\nprint(names[4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJames\nMartin\nSandra\nPaul\nChani\n```\n:::\n:::\n\n\nThis did not take us much time, because the names are only 5, but imagine you have a list of 1000 names; in that case printing all the names could take hours. \nLooking at the previous cell we notice that we use repeatedly the function ```print()``` using as input the values contained in the list ```names```. Every time we need to repeat an operation many times, we can use a **loop**, specifically a for loop: \n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nfor i in range(5):\n    print(i,names[i])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 James\n1 Martin\n2 Sandra\n3 Paul\n4 Chani\n```\n:::\n:::\n\n\nIn the previous cell the same operation (```print()```) is executed 5 times, but at each step, so at each **iteration**, the variable i changes, going from 0 to 4, one step at the time.\n\nIn order to achieve this result we need to start declaring ```for i```. ```i``` is the variable name acting as a place holder for a value that will change at every step of the iteration. We chose the letter i, but you can choose any other name. After ```for i```, we need to specify which values ```i``` can assume at each iteration. ```in range(5)``` means that ```i``` will go from 0 to 4, so it will increase of 1 integer per iteration stopping just before 5. Instead of a range of numbers, we can specify any other object containing several objects in it. In that case, the variable ```i``` (or whatever you will decide to call it), at each iteration, will be initialized with each value contained in the specified object. Let's see some example:\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nfor a in range(12): print(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n```\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nfor value in [0,1,4,5,6,7]:\n    print(value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n4\n5\n6\n7\n```\n:::\n:::\n\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nfor name in names:\n    print(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJames\nMartin\nSandra\nPaul\nChani\n```\n:::\n:::\n\n\nFor *looping* over dictionaries, the concept is the same, but the syntax is a bit different because of the key/value stricture of dictionaries:\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\ninfo_dict = {\n    'name':'Stefano',\n    'surname':'Rapisarda',\n    'favourite_number':6,\n    'favourite_planet':'Saturn'\n}\nfor key,value in info_dict.items():\n    print(key,':',value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nname : Stefano\nsurname : Rapisarda\nfavourite_number : 6\nfavourite_planet : Saturn\n```\n:::\n:::\n\n\n**WARNING** You noticed that after the for statement, there is an indent of 4 spaces. You can make that indent using the TAB key. That indent tells python that that specific line of code is inside the look and, therefore, needs to be repeated. When you write code without indents, before or after the loop, those lines will be executed normally, i.e. once, one after the other.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nprint('Beginning of the for loop, we will have 10 iterations')\nprint('='*72)\nfor i in range(10):\n    print('This is iteration number:',i)\n    print('The next iteration will be:',i+1)\n    print('End of iteration',i)\n    print('-'*62)\nprint('='*72)\nprint('End of the loop')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBeginning of the for loop, we will have 10 iterations\n========================================================================\nThis is iteration number: 0\nThe next iteration will be: 1\nEnd of iteration 0\n--------------------------------------------------------------\nThis is iteration number: 1\nThe next iteration will be: 2\nEnd of iteration 1\n--------------------------------------------------------------\nThis is iteration number: 2\nThe next iteration will be: 3\nEnd of iteration 2\n--------------------------------------------------------------\nThis is iteration number: 3\nThe next iteration will be: 4\nEnd of iteration 3\n--------------------------------------------------------------\nThis is iteration number: 4\nThe next iteration will be: 5\nEnd of iteration 4\n--------------------------------------------------------------\nThis is iteration number: 5\nThe next iteration will be: 6\nEnd of iteration 5\n--------------------------------------------------------------\nThis is iteration number: 6\nThe next iteration will be: 7\nEnd of iteration 6\n--------------------------------------------------------------\nThis is iteration number: 7\nThe next iteration will be: 8\nEnd of iteration 7\n--------------------------------------------------------------\nThis is iteration number: 8\nThe next iteration will be: 9\nEnd of iteration 8\n--------------------------------------------------------------\nThis is iteration number: 9\nThe next iteration will be: 10\nEnd of iteration 9\n--------------------------------------------------------------\n========================================================================\nEnd of the loop\n```\n:::\n:::\n\n\n## Conditional statements {.unnumbered}\n\nWe have seen how to store data and information into variables and how to access this information by indexing, so referring to the position of values inside an object. How about selecting information using other criteria? What about if we want to visualize only peoples names if they are older than 30 or printing the names of towns that start with an 's'?\nTo do that in programming we need to use **conditional statements**. Conditional statements are indeed conditions that need to be satisfied in order for something to happen. What is \"something\"? Whatever action we want: an operation, a printing function, etc.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nfor key,value in info_dict.items():\n    if 'favourite' in key:\n        print(key,':',value)\n    else:\n        print('Not interested!')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNot interested!\nNot interested!\nfavourite_number : 6\nfavourite_planet : Saturn\n```\n:::\n:::\n\n\nWe used the same for loop to explore dictionaries keys and values, but this time, inside it, we wrote a conditional statement. The syntax for a conditional statement is: \n```\nif <condition>: \n    action\nelse:\n    other_action\n```\n```<condition>``` is the condition that needs to be satisfied. In this case we want the word 'favourite' to be contained inside the key. If this happens, the condition is True and the \"action\" is perfomed (in our case, key and value will be printed). If the condition is False, the \"other_action\" will be perfomed (in our case, the 'Not interested' message will be printed).\n\nYou can also make conditions comparing quantities:\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nnumbers = [1,2,3,4,5,6,7]\nfor number in numbers:\n    if number < 4:\n        print(number,'is smaller than 4')\n    elif number > 4:\n        print(number,'is larger than 4')\n    elif number == 4:\n        print(number,'is exactly 4')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 is smaller than 4\n2 is smaller than 4\n3 is smaller than 4\n4 is exactly 4\n5 is larger than 4\n6 is larger than 4\n7 is larger than 4\n```\n:::\n:::\n\n\nConditional statements may also be combined:\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nfor number in numbers:\n    if (number < 4) or (number > 4):\n        print(number, 'is not 4')\n    else:\n        print(number, 'must be 4')\n    \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 is not 4\n2 is not 4\n3 is not 4\n4 must be 4\n5 is not 4\n6 is not 4\n7 is not 4\n```\n:::\n:::\n\n\nIn the previous case we used three conditions that are satisfied if a number is smaller, larger, and equal to 4.\n\nUsing loops in combination with conditional statements is particularly useful when it's time to select data. For example, imagine we have data in a table with two columns, one containes years and the other column can be any kind of measurement. In this case, you can use conditional statements to select measurements and very specific time intervals.\n\n\n## Packages {.unnumbered}\n\nThere are millions of functions and objects out there, how can we use them? Python installation does not come with ALL the functions ever written for Python. Functions and objects are usually organized in **packages** (also called libraries or moduli). Each package contains a set of tools specific for certain tasks. There are tools for statistics, machine learning, building website, text-mining, etc.\nHow can we access all these tools? First of all, we need to download the package into our computer. Usually in the documentation page of the package, there are installation instruction. Once installed, the package needs to be imported.\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n```\n:::\n\n\nIn the previous cell we imported two packages, pandas and pyplot. When we import something, it is convenient to choose an alias for it, so that, when needed, we don't need to write its entire name. In our case, ```pd``` will be the alias for pandas. \n\nIn the second line we see a slightly sifferent statement. In this case, we import the package pyplot. The package is a sub-package of the massive library matplotlib. Therefore, we need to specify the macro-package containing pyplot. We could also import pyplot in the following way.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n```\n:::\n\n\nFrom now on, every time we will need to use a pandas function or object, we just need to specify the alias of the package before the function or object we want to use:\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\ndf = pd.DataFrame()\n```\n:::\n\n\nIn the previous case, we initialised a variable called ```pd``` with a pandas DataFrame. Let's see what happens if we forget to specify ```pd```:\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\ndf = DataFrame()\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'DataFrame' is not defined\n```\n:::\n:::\n\n\nWe obtain an error because Python does not recognize the function name.\n\n",
    "supporting": [
      "intro_to_python_files/figure-pdf"
    ],
    "filters": []
  }
}